# 正则表达式

## 字符集

字符集：规定一位字符上多种备选字的列表

如果 `[]` 中部分备选字符连续，可用 `-` 省略中间字符

```
[3456789] => [3-9] 读作 3 到 9

[A-Za-z]
ASCII: 
- A-Z  65-90  26个
- [\]^_`  91-96
- a-z  97-122
- 汉字 [\u4e00-\u9fa5]  19968-40869 共 20902 个  
```

## 预定义字符集

```
- 一位数字：\d 等效于 [0-9]
- 一位字母、数字、_：\w 等效于 [0-9A-Za-z_]
- 一位空字符(空格、制表符tab、换行等空白)：\s
- 单词边界：\b（代表位置，不是字符）
- 所有文字(通配符)：.
```

## 数量词

```
数量词简写手机号规则：1[3-8]\d{9}
- {n} => 重复 n 次（ n ）
- {n,m} => 最少 n 次，最多 m 次（ [n,m] ）
- {n,} => 最少 n 次（ [n, max] ）
- * => 可有可无，多了不限（ >=0 ）
- ? => 可有可无，最多一次（ 0 || 1 ）
- + => 最少一次，多了不限（ >=1 ）

注意：
正则大部分情况，默认采用贪婪模式匹配，总是尽量匹配最长的那个关键字。
{4,6}：能匹配6位，就不止匹配4位
```

## 选择和分组

选择：指在多个子规则中选其一匹配，用“|”（只分左右，不考虑单个字符）

```
[草|cao] => “草” 或 “cao”
[我草|cao] => “我草” 或 “cao”

- 问题：如果想 “我草” 或 “我cao” 呢？ 使用分组！

我(草|cao) => “我草” 或 “我cao”

- 需求：同时验证同音字或拼音

1. 我([草艹槽]|cao)
2. ([我卧]|wo)([草艹槽]|cao)
3. ([我卧]|wo)\s*([草艹槽]|cao) => 中间不确定个数空字符

- 问题：(我|wo|w) 为什么只能匹配 w，匹配不到 wo
- “|” 不遵守贪婪模式，采用类似短路逻辑的模式，如果前一个匹配，后一个就不再匹配（**前提是在一次匹配中**）
```

## 指定匹配位置

一个字符串中三个位置比较特殊：
- 1.字符串开头
- 2.字符串结尾
- 3.英文句子中的每个单词中间空白位置

```
1. 匹配一组连续的空字符
\s+ => 匹配至少一个空字符（即：连续空字符）
^\s+ => 匹配开头的空字符
\s+$ => 匹配结尾的空字符
^\s+|\s+$ => 匹配开头和结尾的空字符
```

## 修正符（后缀）

```
g：global => 不在首次匹配后停止
m：multi line => 执行多行匹配，^和$分别匹配行首和行尾
i：insensitive => 不区分大小写
y：sticky => 仅从上次匹配结束位置开始匹配
u：unicode => 模式字符串被当成UTF-8
s：single line => 点号.可匹配换行符
```

## 常用正则

```
1. 完整手机号规则
((\+86|0086)\s+)?1[3-9]\d{9}

2. 身份证规则（旧身份证15位数字，新身份证18位，最后一位可能为x）
\d{15}(\d\d[0-9x])?

3. 电子邮件规则

```

## JS中正则表达式的使用

### 1.String 的正则函数

> **查找敏感词**
1. 查找一个固定的敏感词出现的位置 - **indexOf('内容', from)**
```
// 在 str 中查找from位置开始的“敏感词”位置，没有from，从头开始找
var i = str.indexOf('敏感词', from);
``` 
2. 用正则表达式模糊查找一个敏感词位置 - **search(正则)**
```
// search() 不执行全部匹配，它将忽略标志 g
var i = str.search(正则表达式);
```
3. 获取敏感词的内容 - **match(正则)**
* 只获取一个敏感词的内容和位置
```
// 如果找到了敏感词，则返回位置和内容；如果没有找到，返回 null
var str = "我们微信联系";
var arr = str.match(/(微|w(ei)?)\s*(信|x(in)?)/i);
// 打印
0: "微信" // 0 存放匹配到的内容
1: "微"
2: undefined
3: "信"
4: undefined
groups: undefined
index: 2 // index 存放内容位置
input: "我们微信联系"
length: 5
```
* 获取所有敏感词内容
```
// match 如果加了g，就只能返回敏感词的内容，无法返回位置了
// var arr = str.match(正则/g);
var str = 'hello collection';
var arr = str.match(/l+/g);
// 打印
0: "ll"
1: "ll"
length: 2
```

* 既查找所有关键词的内容，又查找每个关键词的位置
RegExp 对象的 exec() 函数解决

> **替换**
* 简单替换：将所有敏感词都替换为统一的新词
```
str.replace(/正则/g, '新词');
// 坑：即使替换不成功，也不会报错；且必须用新值接收，str本身不会改变
```

* 高级替换：根据每次找到的敏感词不同，动态选择不同的新词替换
```
// 需求：将所有英文首字母大写
var str = "you can you up";
// 要求：1. 必须有一个参数接收本次找到的关键词 2. 必须返回处理后的新词
str = str.replace(/\b[a-z]/ig, function(keyword) {
  return keyword.toUpperCase();
});
// replace 会将回调函数返回的新词，替换到本次找到的关键词位置
```

> **切割**
* 简单切割：切割符固定不变
var arr = str.split("切割符");

* 复杂切割：切割符是变化的，但是有规律
// 1.需求：获得用户输入的所有搜索关键词
var keywords = str.split(/\s+/); // 以不确定个数的空格切割

### 2. RegExp 对象
定义：专门保存一条正则表达式，并提供用正则执行查找和验证的 对象。
何时：1.验证 2.高级查找
如何：
1. 创建对象
* 用"/.../"简化版创建
`var reg = /\b[a-z]/ig`
何时：如果正则表达式固定不变
* 用 new 创建
`var reg = new RegExp("\b[a-z]", "ig")`
何时：如果正则表达式需要根据变量或数组内容，动态生成
2. 实例方法
* test
验证字符串格式： `var bool = reg.test(str);`
* exec
`var arr = reg.exec(str);`
作用：在 str 中查找**下一个**关键词的内容和位置
返回值：和 `match` 不加 `g` 的时候是一样的！
      如果找到：返回 `arr[0:内容, index:位置]`
      没找到：返回 `null`